package kubeadm

import (
	"log"

	"github.com/hashicorp/terraform/helper/schema"
)

const (
	defaultPodCIDR           = "10.244.0.0/16"
	defaultServiceCIDR       = "10.96.0.0/12"
	defaultKubernetesVersion = "v1.14.1"
	defaultDNSDomain         = "cluster.local"
)

func dataSourceKubeadm() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceKubeadmRead,

		Schema: map[string]*schema.Schema{
			"api": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"external": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "stable IP/DNS (and port) for the control plane (for example, the load balancer)",
						},
						"internal": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "IP/DNS and port the local API server advertises it's accessible",
						},
						"alt_names": {
							Type:        schema.TypeList,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "List of SANs to use in api-server certificate. Example: 'IP=127.0.0.1,IP=127.0.0.2,DNS=localhost', If empty, SANs will be extracted from the api_servers",
						},
					},
				},
			},
			"token": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "the cluster formation token (autogenerated when empty)",
			},
			"network": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"services": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defaultServiceCIDR,
							Description: "subnet used by k8s services. Defaults to 10.96.0.0/12.",
						},
						"pods": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defaultPodCIDR,
							Description: "subnet used by pods",
						},
						"dns_domain": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defaultDNSDomain,
							Description: "dns domain used by k8s services. Defaults to cluster.local.",
						},
					},
				},
			},
			"images": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"kube_repo": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the kubernetes images repository",
						},
						"etcd_repo": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the etcd image repository",
						},
						"etcd_version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the images repository",
						},
					},
				},
			},
			"etcd": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"endpoints": {
							Type:        schema.TypeList,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "List of etcd servers URLs including host:port",
						},
					},
				},
			},
			"version": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     defaultKubernetesVersion,
				Description: "Kubernetes version to use (Example: v1.6.0).",
			},
			"extra_args": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"api_server": {
							Type:        schema.TypeMap,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "Map of extra flags for running the API server",
						},
						"controller_manager": {
							Type:        schema.TypeMap,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "Map of extra flags for running the Controller Manager",
						},
						"scheduler": {
							Type:        schema.TypeMap,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "Map of extra flags for running the Scheduler",
						},
						"kubelet": {
							Type:        schema.TypeMap,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "Map of extra flags for running the Kubelet",
						},
					},
				},
			},
			"config": {
				Type:     schema.TypeMap,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"init": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"join": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},
		},
	}
}

func dataSourceKubeadmRead(d *schema.ResourceData, meta interface{}) error {
	var err error

	token := d.Get("token").(string)
	if token == "" {
		log.Printf("[DEBUG] [KUBEADM] Generating a random token...")
		token, err = GenerateToken()
		if err != nil {
			return err
		}
		log.Printf("[DEBUG] [KUBEADM] kubeadm token = %s", token)
	}
	d.SetId(token)

	initConfig, err := dataSourceKubeadmReadToInitConfig(d, token)
	if err != nil {
		return err
	}
	log.Printf("[DEBUG] [KUBEADM] init configuration:\n%s", initConfig)

	joinConfig, err := dataSourceKubeadmReadToJoinConfig(d, token)
	if err != nil {
		return err
	}
	log.Printf("[DEBUG] [KUBEADM] join configuration:\n%s", joinConfig)

	config := map[string]string{
		"init": ToTerraformSafeString(initConfig[:]),
		"join": ToTerraformSafeString(joinConfig[:]),
	}

	d.Set("config", config)

	return nil
}
