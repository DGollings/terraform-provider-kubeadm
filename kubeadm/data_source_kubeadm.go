package kubeadm

import (
	"log"

	"github.com/davecgh/go-spew/spew"
	"github.com/hashicorp/terraform/helper/schema"
)

func dataSourceKubeadm() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceKubeadmRead,

		Schema: map[string]*schema.Schema{
			"api": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"external": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "stable IP/DNS (and port) for the control plane (for example, the load balancer)",
						},
						"internal": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "IP/DNS and port the local API server advertises it's accessible",
						},
						"alt_names": {
							Type:        schema.TypeList,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "List of SANs to use in api-server certificate. Example: 'IP=127.0.0.1,IP=127.0.0.2,DNS=localhost', If empty, SANs will be obtained from the external and internal names/IPs",
						},
					},
				},
			},
			"cni": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						// "plugin": {
						// 	Type:        schema.TypeString,
						// 	Optional:    true,
						// 	Default:     "",
						// 	Description: "CNI plugin to install",
						// },
						"bin_dir": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defCniBinDir,
							Description: "Binaries directory for CNI",
						},
						"conf_dir": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defCniConfDir,
							Description: "Configuration directory for CNI",
						},
					},
				},
			},
			"token": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "the cluster formation token (autogenerated when empty)",
			},
			"network": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"services": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defServiceCIDR,
							Description: "subnet used by k8s services. Defaults to 10.96.0.0/12.",
						},
						"pods": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defPodCIDR,
							Description: "subnet used by pods",
						},
						"dns_domain": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defDNSDomain,
							Description: "DNS domain used by k8s services. Defaults to cluster.local.",
						},
					},
				},
			},
			"images": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"kube_repo": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the kubernetes images repository",
						},
						"etcd_repo": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the etcd image repository",
						},
						"etcd_version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "the etcd version",
						},
					},
				},
			},
			"etcd": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"endpoints": {
							Type:        schema.TypeList,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Optional:    true,
							Description: "list of etcd servers URLs including host:port",
						},
					},
				},
			},
			"version": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     defKubernetesVersion,
				Description: "Kubernetes version to use (Example: v1.6.0).",
			},
			"runtime": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"engine": {
							Type:        schema.TypeString,
							Optional:    true,
							Default:     defRuntimeEngine,
							Description: "runtime engine: docker or crio",
						},
						"extra_args": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"api_server": {
										Type:        schema.TypeMap,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Optional:    true,
										Description: "Map of extra flags for running the API server",
									},
									"controller_manager": {
										Type:        schema.TypeMap,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Optional:    true,
										Description: "Map of extra flags for running the Controller Manager",
									},
									"scheduler": {
										Type:        schema.TypeMap,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Optional:    true,
										Description: "Map of extra flags for running the Scheduler",
									},
									"kubelet": {
										Type:        schema.TypeMap,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Optional:    true,
										Description: "Map of extra flags for running the Kubelet",
									},
								},
							},
						},
					},
				},
			},
			"config": {
				Type:     schema.TypeMap,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"init": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"join": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},
		},
	}
}

func dataSourceKubeadmRead(d *schema.ResourceData, meta interface{}) error {
	var err error

	token := d.Get("token").(string)
	if token == "" {
		log.Printf("[DEBUG] [KUBEADM] Generating a random token...")
		token, err = GenerateToken()
		if err != nil {
			return err
		}
		log.Printf("[DEBUG] [KUBEADM] kubeadm token = %s", token)
	}
	d.SetId(token)

	initConfig, err := dataSourceKubeadmReadToInitConfig(d, token)
	if err != nil {
		return err
	}
	log.Printf("[DEBUG] [KUBEADM] init configuration:\n%s", initConfig)

	joinConfig, err := dataSourceKubeadmReadToJoinConfig(d, token)
	if err != nil {
		return err
	}
	log.Printf("[DEBUG] [KUBEADM] join configuration:\n%s", joinConfig)

	config := map[string]string{
		"init": ToTerraformSafeString(initConfig[:]),
		"join": ToTerraformSafeString(joinConfig[:]),
	}

	log.Printf("[DEBUG] [KUBEADM] provisioner configuration:\n%s\n%", spew.Sdump(config))

	d.Set("config", config)

	return nil
}
